
## 闭包

    闭包：闭包是一个概念，简单的讲就是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常用方式就是在一个函数内部创建另外一个函数。

##### 为什么要有闭包？

    在JavaScript中，我们经常需要定义很多的变量，有些变量是在全局空间中，供所有的函数访问。有些变量定义在函数内部，正常情况下，只能在函数内部被访问到。闭包的好处，就是可以在函数外部访问到函数内部定义的变量或方法。

##### 闭包的应用场景

1. 从函数外部读取函数内部的变量

2. 让一些变量始终保存在内存中

下面，我们从作用域链开始入手，慢慢剖析闭包的实现过程。

#### 作用域链

    作用域链，是指每个函数内部都有一个它本身可以访问的一个作用域的链。而作用域是每个函数内部定义变量或函数的空间。

先从一个例子开始：

    var scope = "global";
    function test(){
      console.log(scope);
      var scope = "local";
      console.log(scope);
    }
    test();

第一句输出："underfied"，
第二句输出："local"

分析：要明白这个结果，需要知道一个JavaScript 函数作用域的一个特性。局部变量在整个函数体始终是有定义的，因为变量声明的语句被提前到了函数体顶部，而变量初始化还在原来的位置。所以，上面的代码可以写成：

    var scope = "global";
    function test(){
      var scope;
      console.log(scope);
      scope = "local";
      console.log(scope);
    }
    test();


每个函数作用域链的结构，包括当前函数内部作用域和其外部作用域，然后想外继续扩展，知道全局作用域。

#### 闭包的实现

##### 1. 闭包的简单实现

    function A() {
      var a = "Hello World!";
      function B() {
        console.log(a);
      }
      return B;
    }
    var b = A();
    b();  //Hello World

在这段代码中，把函数 A 赋值给全局变量 b，而函数 A 内部返回了一个函数 B，且函数 B内访问了函数 A 中的局部变量 a。所以，当 b 被赋值为 A()时，就相当于把函数 B 赋值给了 b，由于函数 B有权限访问到 A 内部的局部变量 a，所以 b 也就获得了对 a 的访问权限。

##### 2. 闭包的作用域链

  当某个函数被调用时，会创建一个执行环境（execution context），及相应的作用域链。然后，使用 arguments 和其他命名参数来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链重点的全局执行环境。

  在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。

  上段代码中，函数的执行环境如下图：

  ![](https://github.com/zuaKevin/FrontEndTechSharingPlan/blob/master/images/%E9%97%AD%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.png)

##### 3. 闭包与 GC

  我们知道，JavaScript中有垃圾回收机制（GC:Garbage Collecation），通常我们使用new 创建对象，GC负责回收对象占用的内存区域。

###### GC 是怎么工作的？

  GC在回收内存时，首先会判断该对象是否被其他对象引用。在确定没有被其他对象引用时，变会释放该对象的内存区域。

###### 闭包和 GC

  在上述代码例子中，函数 A 包含函数 B，函数 B内引用了变量 a。所以，当
  全局变量 b 被赋值为 A 时，变量a 和函数 B会一直存在在内存中，在 b 执行完之后，也不会被GC回收。除非把 b 设为 null，解除 b 对函数A 的引用。

###### 注意

根据GC机制，可以看出，闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，造成内存的泄露。

（完）
