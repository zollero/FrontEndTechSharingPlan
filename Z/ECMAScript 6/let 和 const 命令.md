### let

1. ES6 新增了 let 命令，用于声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。（代码块：一对大括号包围的区域）
2. let 不像 var 那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。
3. 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
4. let 不允许在相同作用域内，重复声明同一个变量。


### const 

1. const 也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。
2. 在严格模式下，对const 声明的常量重新赋值会报错；在常规模式下，对该变量重新赋值不会报错，但也是无效的。
3. 在严格模式下，用 const 只声明，不赋值会报错；在常规模式下，不报错，但是重新赋值是无效的。
4. const 的作用域和 let 命令相同：只在声明坐在的块级作用域有效。
5. const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
6. const 声明的常量，也与 let 一样不可重复声明。
7. 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为变量必须非常小心。因为，const 声明的常量储存的是对象的地址，但是该对象本身可以改变，如：改变属性或属性值。
8. 同样，用 const 声明的常量指向的数组本身也是可写的，但是如果将另一个数组赋值给该变量，就会报错。
9. 如果真想将对象冻结，应该使用 Object.freeze 方法。
        const foo = Object.freeze({});
        常量foo指向一个冻结的对象，所以添加新属性不起作用，
        严格模式时还会报错。

